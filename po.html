<!DOCTYPE html>
<html lang="pt-BR">
<head>
<meta charset="UTF-8">
<title>Coração → Racha → Pó</title>
<style>
  body {
    margin: 0;
    overflow: hidden;
    background: #000;
  }
</style>
</head>
<body>

<script src="https://cdn.jsdelivr.net/npm/three@0.158/build/three.min.js"></script>

<script>
// =================== CENA ===================
const scene = new THREE.Scene();

const camera = new THREE.PerspectiveCamera(
  60,
  window.innerWidth / window.innerHeight,
  0.1,
  1000
);
camera.position.z = 22;

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

// =================== LUZ ===================
scene.add(new THREE.AmbientLight(0xff5555, 0.8));
const light = new THREE.PointLight(0xffffff, 1.2);
light.position.set(10, 10, 10);
scene.add(light);

// =================== CORAÇÃO ===================
const shape = new THREE.Shape();
shape.moveTo(0, 2);
shape.bezierCurveTo(0, 2, -4, -2, -6, 2);
shape.bezierCurveTo(-10, 8, 0, 12, 0, 16);
shape.bezierCurveTo(0, 12, 10, 8, 6, 2);
shape.bezierCurveTo(4, -2, 0, 2, 0, 2);

const geometry = new THREE.ExtrudeGeometry(shape, {
  depth: 4,
  bevelEnabled: true,
  bevelThickness: 1,
  bevelSize: 1,
  bevelSegments: 3
});
geometry.center();

// =================== SHADER (RACHADURA) ===================
const heartMaterial = new THREE.ShaderMaterial({
  uniforms: {
    crack: { value: 0 },
    color: { value: new THREE.Color(0xd62828) }
  },
  vertexShader: `
    varying vec3 vPos;
    void main() {
      vPos = position;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position,1.0);
    }
  `,
  fragmentShader: `
    uniform float crack;
    uniform vec3 color;
    varying vec3 vPos;

    float rand(vec2 co){
      return fract(sin(dot(co, vec2(12.9898,78.233))) * 43758.5453);
    }

    void main() {
      float noise = rand(vPos.xy * 15.0);
      float cracks = step(1.0 - crack, noise);
      vec3 finalColor = mix(color, vec3(0.05), cracks);
      gl_FragColor = vec4(finalColor, 1.0);
    }
  `
});

const heart = new THREE.Mesh(geometry, heartMaterial);
heart.rotation.x = Math.PI; // corrigir orientação
scene.add(heart);

// =================== PARTÍCULAS (PÓ) ===================
let particles = null;

function createDust() {
  const positions = [];
  const velocities = [];

  for (let i = 0; i < 2500; i++) {
    positions.push(
      (Math.random() - 0.5) * 6,
      (Math.random() - 0.5) * 6,
      (Math.random() - 0.5) * 6
    );

    velocities.push(
      (Math.random() - 0.5) * 0.25,
      Math.random() * 0.4,
      (Math.random() - 0.5) * 0.25
    );
  }

  const geo = new THREE.BufferGeometry();
  geo.setAttribute("position", new THREE.Float32BufferAttribute(positions, 3));
  geo.setAttribute("velocity", new THREE.Float32BufferAttribute(velocities, 3));

  const mat = new THREE.PointsMaterial({
    color: 0xff4d4d,
    size: 0.1,
    transparent: true
  });

  particles = new THREE.Points(geo, mat);
  scene.add(particles);
}

// =================== CONTROLE ===================
let cracking = false;
let exploding = false;
let crackLevel = 0;

window.addEventListener("click", () => {
  if (!cracking && !exploding) cracking = true;
});

// =================== ANIMAÇÃO ===================
function animate() {
  requestAnimationFrame(animate);

  if (!cracking && !exploding) {
    heart.rotation.y += 0.01;
  }

  if (cracking && crackLevel < 1) {
    crackLevel += 0.01;
    heart.material.uniforms.crack.value = crackLevel;

    if (crackLevel >= 1) {
      heart.visible = false;
      cracking = false;
      exploding = true;
      createDust();
    }
  }

  if (exploding && particles) {
    const pos = particles.geometry.attributes.position;
    const vel = particles.geometry.attributes.velocity;

    for (let i = 0; i < pos.count; i++) {
      vel.array[i*3+1] -= 0.006;
      pos.array[i*3] += vel.array[i*3];
      pos.array[i*3+1] += vel.array[i*3+1];
      pos.array[i*3+2] += vel.array[i*3+2];
    }
    pos.needsUpdate = true;
  }

  renderer.render(scene, camera);
}

animate();

// =================== RESIZE ===================
window.addEventListener("resize", () => {
  camera.aspect = innerWidth / innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(innerWidth, innerHeight);
});
</script>

</body>
</html>
